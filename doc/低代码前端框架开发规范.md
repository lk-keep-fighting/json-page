# 基于 shadcn/ui 的低代码前端框架开发规范

## 1. 框架概述

### 1.1 设计理念
- **组件化**: 基于 shadcn/ui 组件库构建可复用 UI 块
- **配置驱动**: 通过 JSON 配置描述页面结构和行为
- **可视化开发**: 支持拖拽编辑和实时预览
- **类型安全**: 完整的 TypeScript 类型定义

### 1.2 核心特性
- ✅ JSON 驱动的页面渲染
- ✅ 可视化区块编辑器
- ✅ 响应式设计支持
- ✅ 事件和动作系统
- ✅ 条件渲染和动态数据
- ✅ 主题和样式定制

## 2. 项目结构规范

```
low-code-framework/
├── app/                          # Next.js App Router
│   ├── editor/                   # 可视化编辑器
│   ├── preview/                  # 页面预览
│   └── api/                      # API 路由
├── components/
│   ├── blocks/                   # 业务区块组件
│   │   ├── hero-section/
│   │   ├── feature-grid/
│   │   └── pricing-table/
│   ├── ui/                       # shadcn/ui 基础组件
│   ├── renderer/                 # 渲染器核心
│   └── editor/                   # 编辑器组件
├── lib/
│   ├── registry/                 # 组件注册系统
│   ├── schema/                   # JSON Schema 定义
│   ├── parser/                   # 配置解析器
│   └── utils/                    # 工具函数
├── types/                        # TypeScript 类型定义
├── storage/                      # 数据存储层
└── public/                       # 静态资源
```

## 3. 核心类型定义

### 3.1 基础类型 (`types/core.ts`)
```typescript
// 组件基础配置
interface BaseBlockConfig {
  id: string;
  type: string;
  version: string;
  props?: Record<string, any>;
  styles?: StyleConfig;
  layout?: LayoutConfig;
  children?: BlockConfig[];
  conditions?: ConditionConfig[];
  actions?: ActionConfig[];
  dataSource?: DataSourceConfig;
}

// 样式配置
interface StyleConfig {
  className?: string;
  responsive?: {
    mobile?: Record<string, any>;
    tablet?: Record<string, any>;
    desktop?: Record<string, any>;
  };
  customCSS?: string;
}

// 布局配置
interface LayoutConfig {
  grid?: {
    columns?: number;
    gap?: number;
    alignment?: 'start' | 'center' | 'end';
  };
  flex?: {
    direction?: 'row' | 'column';
    justify?: 'start' | 'center' | 'end' | 'between';
    align?: 'start' | 'center' | 'end';
  };
}

// 条件渲染
interface ConditionConfig {
  expression: string;  // JavaScript 表达式
  operator: 'show' | 'hide' | 'enable' | 'disable';
}

// 数据源配置
interface DataSourceConfig {
  type: 'api' | 'static' | 'localStorage' | 'context';
  endpoint?: string;
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  params?: Record<string, any>;
  mapping?: Record<string, string>;
  polling?: number; // 轮询间隔
}
```

### 3.2 动作系统 (`types/actions.ts`)
```typescript
// 动作配置
interface ActionConfig {
  trigger: 'click' | 'submit' | 'change' | 'load';
  type: 'navigate' | 'apiCall' | 'showModal' | 'setState' | 'custom';
  target?: string;
  payload?: Record<string, any>;
  success?: ActionConfig[];
  error?: ActionConfig[];
}

// 动作处理器
interface ActionHandler {
  type: string;
  execute: (config: ActionConfig, context: ActionContext) => Promise<void>;
}

interface ActionContext {
  blockId: string;
  event: any;
  state: Record<string, any>;
  setState: (updates: Record<string, any>) => void;
}
```

## 4. 组件注册规范

### 4.1 注册表定义 (`lib/registry/index.ts`)
```typescript
// 组件元数据
interface ComponentMetadata {
  name: string;
  displayName: string;
  category: string;
  description: string;
  icon: string;
  version: string;
  propsSchema: JSONSchema7;
  defaultProps?: Record<string, any>;
  defaultStyles?: StyleConfig;
  isContainer?: boolean;
}

// 组件注册表
class ComponentRegistry {
  private components: Map<string, ComponentMetadata> = new Map();
  private factories: Map<string, ComponentFactory> = new Map();

  // 注册组件
  register(metadata: ComponentMetadata, factory: ComponentFactory): void {
    this.components.set(metadata.name, metadata);
    this.factories.set(metadata.name, factory);
  }

  // 获取组件列表（按分类）
  getComponentsByCategory(): Record<string, ComponentMetadata[]> {
    const categories: Record<string, ComponentMetadata[]> = {};
    
    this.components.forEach(metadata => {
      if (!categories[metadata.category]) {
        categories[metadata.category] = [];
      }
      categories[metadata.category].push(metadata);
    });
    
    return categories;
  }

  // 获取组件工厂
  getFactory(type: string): ComponentFactory | undefined {
    return this.factories.get(type);
  }

  // 验证配置
  validateConfig(config: BlockConfig): ValidationResult {
    const metadata = this.components.get(config.type);
    if (!metadata) {
      return { valid: false, errors: [`Component ${config.type} not found`] };
    }

    return validateProps(config.props, metadata.propsSchema);
  }
}
```

### 4.2 组件工厂模式 (`lib/registry/factory.ts`)
```typescript
// 组件工厂接口
interface ComponentFactory {
  create: (config: BlockConfig, context: RenderContext) => React.ReactElement;
}

// 渲染上下文
interface RenderContext {
  state: Record<string, any>;
  setState: (updates: Record<string, any>) => void;
  executeAction: (action: ActionConfig, event?: any) => Promise<void>;
  dataSources: Record<string, any>;
}

// 基础组件工厂
class BaseComponentFactory implements ComponentFactory {
  create(config: BlockConfig, context: RenderContext): React.ReactElement {
    const Component = componentRegistry.get(config.type);
    
    if (!Component) {
      return <div>Component {config.type} not found</div>;
    }

    // 处理数据绑定
    const processedProps = this.processProps(config.props, context);
    
    // 处理样式
    const className = this.processStyles(config.styles);
    
    return (
      <Component 
        {...processedProps}
        className={className}
        data-block-id={config.id}
      >
        {this.renderChildren(config.children, context)}
      </Component>
    );
  }

  private processProps(props: Record<string, any>, context: RenderContext) {
    return Object.entries(props).reduce((acc, [key, value]) => {
      acc[key] = this.processValue(value, context);
      return acc;
    }, {} as Record<string, any>);
  }

  private processValue(value: any, context: RenderContext): any {
    if (typeof value === 'string' && value.startsWith('{{') && value.endsWith('}}')) {
      // 处理模板表达式
      return this.evaluateExpression(value.slice(2, -2), context);
    }
    return value;
  }

  private evaluateExpression(expr: string, context: RenderContext): any {
    // 安全地执行 JavaScript 表达式
    try {
      const func = new Function('state', 'data', `return ${expr}`);
      return func(context.state, context.dataSources);
    } catch (error) {
      console.error(`Expression evaluation error: ${expr}`, error);
      return null;
    }
  }
}
```

## 5. JSON Schema 规范

### 5.1 页面配置 Schema (`lib/schema/page.ts`)
```typescript
export const PageSchema = {
  type: 'object',
  properties: {
    meta: {
      type: 'object',
      properties: {
        title: { type: 'string' },
        description: { type: 'string' },
        route: { type: 'string', pattern: '^/' },
        layout: { type: 'string', enum: ['default', 'dashboard', 'auth'] }
      },
      required: ['title', 'route']
    },
    state: {
      type: 'object',
      additionalProperties: true
    },
    dataSources: {
      type: 'object',
      additionalProperties: {
        type: 'object',
        properties: {
          type: { type: 'string', enum: ['api', 'static', 'localStorage'] },
          endpoint: { type: 'string' },
          method: { type: 'string', enum: ['GET', 'POST', 'PUT', 'DELETE'] },
          params: { type: 'object' },
          polling: { type: 'number', minimum: 0 }
        }
      }
    },
    blocks: {
      type: 'array',
      items: { $ref: '#/definitions/block' }
    }
  },
  required: ['meta', 'blocks'],
  definitions: {
    block: {
      type: 'object',
      properties: {
        id: { type: 'string' },
        type: { type: 'string' },
        props: { type: 'object' },
        styles: { $ref: '#/definitions/styles' },
        layout: { $ref: '#/definitions/layout' },
        children: {
          type: 'array',
          items: { $ref: '#/definitions/block' }
        },
        conditions: {
          type: 'array',
          items: { $ref: '#/definitions/condition' }
        }
      },
      required: ['id', 'type']
    }
  }
} as const;
```

## 6. 渲染引擎规范

### 6.1 JSON 渲染器 (`components/renderer/json-renderer.tsx`)
```typescript
interface JSONRendererProps {
  config: BlockConfig;
  context: RenderContext;
  parentId?: string;
}

export const JSONRenderer: React.FC<JSONRendererProps> = ({
  config,
  context,
  parentId
}) => {
  // 条件渲染检查
  if (!evaluateConditions(config.conditions, context)) {
    return null;
  }

  // 获取组件工厂
  const factory = componentRegistry.getFactory(config.type);
  
  if (!factory) {
    console.warn(`Component factory not found: ${config.type}`);
    return null;
  }

  try {
    return factory.create(config, {
      ...context,
      parentId
    });
  } catch (error) {
    console.error(`Error rendering component ${config.type}:`, error);
    return (
      <div className="p-4 border border-red-300 bg-red-50 rounded">
        <p className="text-red-700">渲染错误: {config.type}</p>
        <p className="text-sm text-red-600">{error.message}</p>
      </div>
    );
  }
};

// 条件求值器
function evaluateConditions(
  conditions: ConditionConfig[] = [], 
  context: RenderContext
): boolean {
  return conditions.every(condition => {
    try {
      const result = evaluateExpression(condition.expression, context);
      return condition.operator === 'show' ? result : !result;
    } catch (error) {
      console.error('Condition evaluation error:', error);
      return false;
    }
  });
}
```

### 6.2 页面渲染器 (`components/renderer/page-renderer.tsx`)
```typescript
interface PageRendererProps {
  pageConfig: PageConfig;
  mode?: 'preview' | 'runtime';
}

export const PageRenderer: React.FC<PageRendererProps> = ({
  pageConfig,
  mode = 'runtime'
}) => {
  const [state, setState] = useState(pageConfig.state || {});
  const [dataSources, setDataSources] = useState<Record<string, any>>({});

  // 初始化数据源
  useEffect(() => {
    initializeDataSources(pageConfig.dataSources, setDataSources);
  }, [pageConfig.dataSources]);

  // 动作执行器
  const executeAction = useCallback(async (action: ActionConfig, event?: any) => {
    const handler = actionHandlers.get(action.type);
    if (handler) {
      await handler.execute(action, {
        blockId: action.target || '',
        event,
        state,
        setState: (updates) => setState(prev => ({ ...prev, ...updates })),
        dataSources
      });
    }
  }, [state, dataSources]);

  const renderContext: RenderContext = {
    state,
    setState: (updates) => setState(prev => ({ ...prev, ...updates })),
    executeAction,
    dataSources
  };

  return (
    <div className={`page-renderer ${mode}`}>
      {pageConfig.blocks.map(block => (
        <JSONRenderer
          key={block.id}
          config={block}
          context={renderContext}
        />
      ))}
    </div>
  );
};
```

## 7. 可视化编辑器规范

### 7.1 编辑器架构 (`components/editor/block-editor.tsx`)
```typescript
interface BlockEditorProps {
  initialConfig?: PageConfig;
  onSave?: (config: PageConfig) => void;
  onPublish?: (config: PageConfig) => void;
}

export const BlockEditor: React.FC<BlockEditorProps> = ({
  initialConfig,
  onSave,
  onPublish
}) => {
  const [pageConfig, setPageConfig] = useState<PageConfig>(
    initialConfig || createDefaultPageConfig()
  );
  const [selectedBlockId, setSelectedBlockId] = useState<string>();
  const [history, setHistory] = useState<PageConfig[]>([]);
  const [historyIndex, setHistoryIndex] = useState(0);

  // 添加区块
  const addBlock = useCallback((type: string, parentId?: string) => {
    const newBlock: BlockConfig = {
      id: generateId(),
      type,
      props: componentRegistry.getDefaultProps(type),
      styles: componentRegistry.getDefaultStyles(type)
    };

    setPageConfig(prev => {
      const updated = parentId 
        ? addBlockToParent(prev, newBlock, parentId)
        : addBlockToPage(prev, newBlock);
      
      addToHistory(updated);
      return updated;
    });
  }, []);

  // 更新区块属性
  const updateBlock = useCallback((blockId: string, updates: Partial<BlockConfig>) => {
    setPageConfig(prev => {
      const updated = updateBlockInPage(prev, blockId, updates);
      addToHistory(updated);
      return updated;
    });
  }, []);

  // 删除区块
  const deleteBlock = useCallback((blockId: string) => {
    setPageConfig(prev => {
      const updated = removeBlockFromPage(prev, blockId);
      addToHistory(updated);
      return updated;
    });
    setSelectedBlockId(undefined);
  }, []);

  const selectedBlock = selectedBlockId 
    ? findBlockById(pageConfig.blocks, selectedBlockId)
    : undefined;

  return (
    <div className="editor-container h-screen flex">
      {/* 组件面板 */}
      <ComponentPalette onComponentSelect={addBlock} />
      
      {/* 画布区域 */}
      <div className="flex-1 flex flex-col">
        <EditorToolbar
          config={pageConfig}
          onSave={onSave}
          onPublish={onPublish}
          onUndo={undo}
          onRedo={redo}
        />
        
        <div className="flex-1 overflow-auto">
          <EditableCanvas
            config={pageConfig}
            selectedBlockId={selectedBlockId}
            onBlockSelect={setSelectedBlockId}
            onBlockUpdate={updateBlock}
            onBlockDelete={deleteBlock}
          />
        </div>
      </div>
      
      {/* 属性面板 */}
      <PropertyPanel
        block={selectedBlock}
        onUpdate={(updates) => selectedBlockId && updateBlock(selectedBlockId, updates)}
      />
    </div>
  );
};
```

## 8. 数据源管理规范

### 8.1 数据源管理器 (`lib/data/data-source-manager.ts`)
```typescript
class DataSourceManager {
  private sources: Map<string, DataSourceConfig> = new Map();
  private cache: Map<string, any> = new Map();
  private subscribers: Map<string, Function[]> = new Map();

  // 注册数据源
  registerSource(id: string, config: DataSourceConfig): void {
    this.sources.set(id, config);
    
    if (config.type === 'api' && config.polling) {
      this.startPolling(id, config);
    }
  }

  // 获取数据
  async getData(sourceId: string, params?: Record<string, any>): Promise<any> {
    const config = this.sources.get(sourceId);
    if (!config) {
      throw new Error(`Data source not found: ${sourceId}`);
    }

    const cacheKey = this.generateCacheKey(sourceId, params);
    
    // 检查缓存
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const data = await this.fetchData(config, params);
    this.cache.set(cacheKey, data);
    this.notifySubscribers(sourceId, data);
    
    return data;
  }

  // 数据获取实现
  private async fetchData(config: DataSourceConfig, params?: Record<string, any>) {
    switch (config.type) {
      case 'api':
        return this.fetchFromAPI(config, params);
      case 'static':
        return config.data;
      case 'localStorage':
        return this.getFromLocalStorage(config.key!);
      default:
        throw new Error(`Unsupported data source type: ${config.type}`);
    }
  }

  private async fetchFromAPI(config: DataSourceConfig, params?: Record<string, any>) {
    const url = this.buildURL(config.endpoint!, params);
    const response = await fetch(url, {
      method: config.method || 'GET',
      headers: config.headers,
      body: config.method !== 'GET' ? JSON.stringify(params) : undefined
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }

    const data = await response.json();
    return config.mapping ? this.mapData(data, config.mapping) : data;
  }
}
```

## 9. 部署和构建规范

### 9.1 构建配置
```typescript
// next.config.js
const withLowCode = (nextConfig = {}) => {
  return {
    ...nextConfig,
    env: {
      ...nextConfig.env,
      LOW_CODE_ENV: process.env.NODE_ENV,
    },
    webpack: (config, options) => {
      // 添加 JSON loader
      config.module.rules.push({
        test: /\.json$/,
        type: 'javascript/auto',
        use: ['json-loader']
      });

      return nextConfig.webpack?.(config, options) || config;
    }
  };
};

module.exports = withLowCode({
  reactStrictMode: true,
  swcMinify: true,
});
```

## 10. 开发工作流

### 10.1 组件开发流程
1. **创建组件**: 在 `components/blocks/` 下创建新组件
2. **定义 Schema**: 创建对应的 JSON Schema 定义
3. **注册组件**: 在注册表中注册组件和工厂
4. **测试组件**: 在编辑器中测试组件功能
5. **文档化**: 更新组件文档和使用示例

### 10.2 页面开发流程
1. **设计页面**: 在编辑器中拖拽组件构建页面
2. **配置属性**: 通过属性面板配置组件行为
3. **设置数据**: 配置数据源和状态管理
4. **定义交互**: 设置动作和事件处理
5. **发布页面**: 导出 JSON 配置或发布到生产环境

## 11. 质量保证

### 11.1 测试策略
- ✅ 单元测试: 组件工厂、数据源管理器
- ✅ 集成测试: 渲染引擎、动作系统
- ✅ E2E 测试: 编辑器工作流、页面渲染
- ✅ 性能测试: 大型页面渲染性能

### 11.2 代码规范
- 使用 ESLint + Prettier 统一代码风格
- TypeScript 严格模式
- 组件必须包含 PropTypes 或 TypeScript 定义
- 所有公共 API 必须有文档注释
